// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"autopilot/backends/internal/core"
	"context"
	"database/sql"
	"io"
	"io/fs"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/jmoiron/sqlx"
	"github.com/riverqueue/river"
	"github.com/riverqueue/river/rivertype"
	mock "github.com/stretchr/testify/mock"
)

// NewMockQuerier creates a new instance of MockQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockQuerier {
	mock := &MockQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockQuerier is an autogenerated mock type for the Querier type
type MockQuerier struct {
	mock.Mock
}

type MockQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockQuerier) EXPECT() *MockQuerier_Expecter {
	return &MockQuerier_Expecter{mock: &_m.Mock}
}

// Exec provides a mock function for the type MockQuerier
func (_mock *MockQuerier) Exec(query string, args ...any) (sql.Result, error) {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(query, args)
	} else {
		tmpRet = _mock.Called(query)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 sql.Result
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, ...any) (sql.Result, error)); ok {
		return returnFunc(query, args...)
	}
	if returnFunc, ok := ret.Get(0).(func(string, ...any) sql.Result); ok {
		r0 = returnFunc(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(sql.Result)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, ...any) error); ok {
		r1 = returnFunc(query, args...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockQuerier_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - query string
//   - args ...any
func (_e *MockQuerier_Expecter) Exec(query interface{}, args ...interface{}) *MockQuerier_Exec_Call {
	return &MockQuerier_Exec_Call{Call: _e.mock.On("Exec",
		append([]interface{}{query}, args...)...)}
}

func (_c *MockQuerier_Exec_Call) Run(run func(query string, args ...any)) *MockQuerier_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []any
		var variadicArgs []any
		if len(args) > 1 {
			variadicArgs = args[1].([]any)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockQuerier_Exec_Call) Return(result sql.Result, err error) *MockQuerier_Exec_Call {
	_c.Call.Return(result, err)
	return _c
}

func (_c *MockQuerier_Exec_Call) RunAndReturn(run func(query string, args ...any) (sql.Result, error)) *MockQuerier_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// ExecContext provides a mock function for the type MockQuerier
func (_mock *MockQuerier) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, query, args)
	} else {
		tmpRet = _mock.Called(ctx, query)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ExecContext")
	}

	var r0 sql.Result
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) (sql.Result, error)); ok {
		return returnFunc(ctx, query, args...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) sql.Result); ok {
		r0 = returnFunc(ctx, query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(sql.Result)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, ...any) error); ok {
		r1 = returnFunc(ctx, query, args...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_ExecContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecContext'
type MockQuerier_ExecContext_Call struct {
	*mock.Call
}

// ExecContext is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - args ...any
func (_e *MockQuerier_Expecter) ExecContext(ctx interface{}, query interface{}, args ...interface{}) *MockQuerier_ExecContext_Call {
	return &MockQuerier_ExecContext_Call{Call: _e.mock.On("ExecContext",
		append([]interface{}{ctx, query}, args...)...)}
}

func (_c *MockQuerier_ExecContext_Call) Run(run func(ctx context.Context, query string, args ...any)) *MockQuerier_ExecContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []any
		var variadicArgs []any
		if len(args) > 2 {
			variadicArgs = args[2].([]any)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockQuerier_ExecContext_Call) Return(result sql.Result, err error) *MockQuerier_ExecContext_Call {
	_c.Call.Return(result, err)
	return _c
}

func (_c *MockQuerier_ExecContext_Call) RunAndReturn(run func(ctx context.Context, query string, args ...any) (sql.Result, error)) *MockQuerier_ExecContext_Call {
	_c.Call.Return(run)
	return _c
}

// PrepareContext provides a mock function for the type MockQuerier
func (_mock *MockQuerier) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) {
	ret := _mock.Called(ctx, query)

	if len(ret) == 0 {
		panic("no return value specified for PrepareContext")
	}

	var r0 *sql.Stmt
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*sql.Stmt, error)); ok {
		return returnFunc(ctx, query)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *sql.Stmt); ok {
		r0 = returnFunc(ctx, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.Stmt)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, query)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_PrepareContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PrepareContext'
type MockQuerier_PrepareContext_Call struct {
	*mock.Call
}

// PrepareContext is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
func (_e *MockQuerier_Expecter) PrepareContext(ctx interface{}, query interface{}) *MockQuerier_PrepareContext_Call {
	return &MockQuerier_PrepareContext_Call{Call: _e.mock.On("PrepareContext", ctx, query)}
}

func (_c *MockQuerier_PrepareContext_Call) Run(run func(ctx context.Context, query string)) *MockQuerier_PrepareContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_PrepareContext_Call) Return(stmt *sql.Stmt, err error) *MockQuerier_PrepareContext_Call {
	_c.Call.Return(stmt, err)
	return _c
}

func (_c *MockQuerier_PrepareContext_Call) RunAndReturn(run func(ctx context.Context, query string) (*sql.Stmt, error)) *MockQuerier_PrepareContext_Call {
	_c.Call.Return(run)
	return _c
}

// Query provides a mock function for the type MockQuerier
func (_mock *MockQuerier) Query(query string, args ...any) (*sql.Rows, error) {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(query, args)
	} else {
		tmpRet = _mock.Called(query)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 *sql.Rows
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, ...any) (*sql.Rows, error)); ok {
		return returnFunc(query, args...)
	}
	if returnFunc, ok := ret.Get(0).(func(string, ...any) *sql.Rows); ok {
		r0 = returnFunc(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.Rows)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, ...any) error); ok {
		r1 = returnFunc(query, args...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_Query_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Query'
type MockQuerier_Query_Call struct {
	*mock.Call
}

// Query is a helper method to define mock.On call
//   - query string
//   - args ...any
func (_e *MockQuerier_Expecter) Query(query interface{}, args ...interface{}) *MockQuerier_Query_Call {
	return &MockQuerier_Query_Call{Call: _e.mock.On("Query",
		append([]interface{}{query}, args...)...)}
}

func (_c *MockQuerier_Query_Call) Run(run func(query string, args ...any)) *MockQuerier_Query_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []any
		var variadicArgs []any
		if len(args) > 1 {
			variadicArgs = args[1].([]any)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockQuerier_Query_Call) Return(rows *sql.Rows, err error) *MockQuerier_Query_Call {
	_c.Call.Return(rows, err)
	return _c
}

func (_c *MockQuerier_Query_Call) RunAndReturn(run func(query string, args ...any) (*sql.Rows, error)) *MockQuerier_Query_Call {
	_c.Call.Return(run)
	return _c
}

// QueryContext provides a mock function for the type MockQuerier
func (_mock *MockQuerier) QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error) {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, query, args)
	} else {
		tmpRet = _mock.Called(ctx, query)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for QueryContext")
	}

	var r0 *sql.Rows
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) (*sql.Rows, error)); ok {
		return returnFunc(ctx, query, args...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) *sql.Rows); ok {
		r0 = returnFunc(ctx, query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.Rows)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, ...any) error); ok {
		r1 = returnFunc(ctx, query, args...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_QueryContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryContext'
type MockQuerier_QueryContext_Call struct {
	*mock.Call
}

// QueryContext is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - args ...any
func (_e *MockQuerier_Expecter) QueryContext(ctx interface{}, query interface{}, args ...interface{}) *MockQuerier_QueryContext_Call {
	return &MockQuerier_QueryContext_Call{Call: _e.mock.On("QueryContext",
		append([]interface{}{ctx, query}, args...)...)}
}

func (_c *MockQuerier_QueryContext_Call) Run(run func(ctx context.Context, query string, args ...any)) *MockQuerier_QueryContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []any
		var variadicArgs []any
		if len(args) > 2 {
			variadicArgs = args[2].([]any)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockQuerier_QueryContext_Call) Return(rows *sql.Rows, err error) *MockQuerier_QueryContext_Call {
	_c.Call.Return(rows, err)
	return _c
}

func (_c *MockQuerier_QueryContext_Call) RunAndReturn(run func(ctx context.Context, query string, args ...any) (*sql.Rows, error)) *MockQuerier_QueryContext_Call {
	_c.Call.Return(run)
	return _c
}

// QueryRow provides a mock function for the type MockQuerier
func (_mock *MockQuerier) QueryRow(query string, args ...any) *sql.Row {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(query, args)
	} else {
		tmpRet = _mock.Called(query)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for QueryRow")
	}

	var r0 *sql.Row
	if returnFunc, ok := ret.Get(0).(func(string, ...any) *sql.Row); ok {
		r0 = returnFunc(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.Row)
		}
	}
	return r0
}

// MockQuerier_QueryRow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryRow'
type MockQuerier_QueryRow_Call struct {
	*mock.Call
}

// QueryRow is a helper method to define mock.On call
//   - query string
//   - args ...any
func (_e *MockQuerier_Expecter) QueryRow(query interface{}, args ...interface{}) *MockQuerier_QueryRow_Call {
	return &MockQuerier_QueryRow_Call{Call: _e.mock.On("QueryRow",
		append([]interface{}{query}, args...)...)}
}

func (_c *MockQuerier_QueryRow_Call) Run(run func(query string, args ...any)) *MockQuerier_QueryRow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []any
		var variadicArgs []any
		if len(args) > 1 {
			variadicArgs = args[1].([]any)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockQuerier_QueryRow_Call) Return(row *sql.Row) *MockQuerier_QueryRow_Call {
	_c.Call.Return(row)
	return _c
}

func (_c *MockQuerier_QueryRow_Call) RunAndReturn(run func(query string, args ...any) *sql.Row) *MockQuerier_QueryRow_Call {
	_c.Call.Return(run)
	return _c
}

// QueryRowContext provides a mock function for the type MockQuerier
func (_mock *MockQuerier) QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, query, args)
	} else {
		tmpRet = _mock.Called(ctx, query)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for QueryRowContext")
	}

	var r0 *sql.Row
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...any) *sql.Row); ok {
		r0 = returnFunc(ctx, query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.Row)
		}
	}
	return r0
}

// MockQuerier_QueryRowContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryRowContext'
type MockQuerier_QueryRowContext_Call struct {
	*mock.Call
}

// QueryRowContext is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - args ...any
func (_e *MockQuerier_Expecter) QueryRowContext(ctx interface{}, query interface{}, args ...interface{}) *MockQuerier_QueryRowContext_Call {
	return &MockQuerier_QueryRowContext_Call{Call: _e.mock.On("QueryRowContext",
		append([]interface{}{ctx, query}, args...)...)}
}

func (_c *MockQuerier_QueryRowContext_Call) Run(run func(ctx context.Context, query string, args ...any)) *MockQuerier_QueryRowContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []any
		var variadicArgs []any
		if len(args) > 2 {
			variadicArgs = args[2].([]any)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockQuerier_QueryRowContext_Call) Return(row *sql.Row) *MockQuerier_QueryRowContext_Call {
	_c.Call.Return(row)
	return _c
}

func (_c *MockQuerier_QueryRowContext_Call) RunAndReturn(run func(ctx context.Context, query string, args ...any) *sql.Row) *MockQuerier_QueryRowContext_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockDBer creates a new instance of MockDBer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDBer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockDBer {
	mock := &MockDBer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockDBer is an autogenerated mock type for the DBer type
type MockDBer struct {
	mock.Mock
}

type MockDBer_Expecter struct {
	mock *mock.Mock
}

func (_m *MockDBer) EXPECT() *MockDBer_Expecter {
	return &MockDBer_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockDBer
func (_mock *MockDBer) Close() {
	_mock.Called()
	return
}

// MockDBer_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockDBer_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockDBer_Expecter) Close() *MockDBer_Close_Call {
	return &MockDBer_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockDBer_Close_Call) Run(run func()) *MockDBer_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockDBer_Close_Call) Return() *MockDBer_Close_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockDBer_Close_Call) RunAndReturn(run func()) *MockDBer_Close_Call {
	_c.Run(run)
	return _c
}

// GenMigration provides a mock function for the type MockDBer
func (_mock *MockDBer) GenMigration(name string) error {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for GenMigration")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockDBer_GenMigration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenMigration'
type MockDBer_GenMigration_Call struct {
	*mock.Call
}

// GenMigration is a helper method to define mock.On call
//   - name string
func (_e *MockDBer_Expecter) GenMigration(name interface{}) *MockDBer_GenMigration_Call {
	return &MockDBer_GenMigration_Call{Call: _e.mock.On("GenMigration", name)}
}

func (_c *MockDBer_GenMigration_Call) Run(run func(name string)) *MockDBer_GenMigration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockDBer_GenMigration_Call) Return(err error) *MockDBer_GenMigration_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDBer_GenMigration_Call) RunAndReturn(run func(name string) error) *MockDBer_GenMigration_Call {
	_c.Call.Return(run)
	return _c
}

// HealthCheck provides a mock function for the type MockDBer
func (_mock *MockDBer) HealthCheck(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for HealthCheck")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockDBer_HealthCheck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HealthCheck'
type MockDBer_HealthCheck_Call struct {
	*mock.Call
}

// HealthCheck is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDBer_Expecter) HealthCheck(ctx interface{}) *MockDBer_HealthCheck_Call {
	return &MockDBer_HealthCheck_Call{Call: _e.mock.On("HealthCheck", ctx)}
}

func (_c *MockDBer_HealthCheck_Call) Run(run func(ctx context.Context)) *MockDBer_HealthCheck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockDBer_HealthCheck_Call) Return(err error) *MockDBer_HealthCheck_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDBer_HealthCheck_Call) RunAndReturn(run func(ctx context.Context) error) *MockDBer_HealthCheck_Call {
	_c.Call.Return(run)
	return _c
}

// Identifier provides a mock function for the type MockDBer
func (_mock *MockDBer) Identifier() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Identifier")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockDBer_Identifier_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Identifier'
type MockDBer_Identifier_Call struct {
	*mock.Call
}

// Identifier is a helper method to define mock.On call
func (_e *MockDBer_Expecter) Identifier() *MockDBer_Identifier_Call {
	return &MockDBer_Identifier_Call{Call: _e.mock.On("Identifier")}
}

func (_c *MockDBer_Identifier_Call) Run(run func()) *MockDBer_Identifier_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockDBer_Identifier_Call) Return(s string) *MockDBer_Identifier_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockDBer_Identifier_Call) RunAndReturn(run func() string) *MockDBer_Identifier_Call {
	_c.Call.Return(run)
	return _c
}

// Migrate provides a mock function for the type MockDBer
func (_mock *MockDBer) Migrate(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Migrate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockDBer_Migrate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Migrate'
type MockDBer_Migrate_Call struct {
	*mock.Call
}

// Migrate is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDBer_Expecter) Migrate(ctx interface{}) *MockDBer_Migrate_Call {
	return &MockDBer_Migrate_Call{Call: _e.mock.On("Migrate", ctx)}
}

func (_c *MockDBer_Migrate_Call) Run(run func(ctx context.Context)) *MockDBer_Migrate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockDBer_Migrate_Call) Return(err error) *MockDBer_Migrate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDBer_Migrate_Call) RunAndReturn(run func(ctx context.Context) error) *MockDBer_Migrate_Call {
	_c.Call.Return(run)
	return _c
}

// MigrateStatus provides a mock function for the type MockDBer
func (_mock *MockDBer) MigrateStatus(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for MigrateStatus")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockDBer_MigrateStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MigrateStatus'
type MockDBer_MigrateStatus_Call struct {
	*mock.Call
}

// MigrateStatus is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDBer_Expecter) MigrateStatus(ctx interface{}) *MockDBer_MigrateStatus_Call {
	return &MockDBer_MigrateStatus_Call{Call: _e.mock.On("MigrateStatus", ctx)}
}

func (_c *MockDBer_MigrateStatus_Call) Run(run func(ctx context.Context)) *MockDBer_MigrateStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockDBer_MigrateStatus_Call) Return(n int64, err error) *MockDBer_MigrateStatus_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockDBer_MigrateStatus_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockDBer_MigrateStatus_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function for the type MockDBer
func (_mock *MockDBer) Name() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockDBer_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type MockDBer_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *MockDBer_Expecter) Name() *MockDBer_Name_Call {
	return &MockDBer_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *MockDBer_Name_Call) Run(run func()) *MockDBer_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockDBer_Name_Call) Return(s string) *MockDBer_Name_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockDBer_Name_Call) RunAndReturn(run func() string) *MockDBer_Name_Call {
	_c.Call.Return(run)
	return _c
}

// Options provides a mock function for the type MockDBer
func (_mock *MockDBer) Options() core.DBOptions {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 core.DBOptions
	if returnFunc, ok := ret.Get(0).(func() core.DBOptions); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(core.DBOptions)
	}
	return r0
}

// MockDBer_Options_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Options'
type MockDBer_Options_Call struct {
	*mock.Call
}

// Options is a helper method to define mock.On call
func (_e *MockDBer_Expecter) Options() *MockDBer_Options_Call {
	return &MockDBer_Options_Call{Call: _e.mock.On("Options")}
}

func (_c *MockDBer_Options_Call) Run(run func()) *MockDBer_Options_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockDBer_Options_Call) Return(dBOptions core.DBOptions) *MockDBer_Options_Call {
	_c.Call.Return(dBOptions)
	return _c
}

func (_c *MockDBer_Options_Call) RunAndReturn(run func() core.DBOptions) *MockDBer_Options_Call {
	_c.Call.Return(run)
	return _c
}

// Reader provides a mock function for the type MockDBer
func (_mock *MockDBer) Reader() *sqlx.DB {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Reader")
	}

	var r0 *sqlx.DB
	if returnFunc, ok := ret.Get(0).(func() *sqlx.DB); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sqlx.DB)
		}
	}
	return r0
}

// MockDBer_Reader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reader'
type MockDBer_Reader_Call struct {
	*mock.Call
}

// Reader is a helper method to define mock.On call
func (_e *MockDBer_Expecter) Reader() *MockDBer_Reader_Call {
	return &MockDBer_Reader_Call{Call: _e.mock.On("Reader")}
}

func (_c *MockDBer_Reader_Call) Run(run func()) *MockDBer_Reader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockDBer_Reader_Call) Return(dB *sqlx.DB) *MockDBer_Reader_Call {
	_c.Call.Return(dB)
	return _c
}

func (_c *MockDBer_Reader_Call) RunAndReturn(run func() *sqlx.DB) *MockDBer_Reader_Call {
	_c.Call.Return(run)
	return _c
}

// Seed provides a mock function for the type MockDBer
func (_mock *MockDBer) Seed(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Seed")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockDBer_Seed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Seed'
type MockDBer_Seed_Call struct {
	*mock.Call
}

// Seed is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDBer_Expecter) Seed(ctx interface{}) *MockDBer_Seed_Call {
	return &MockDBer_Seed_Call{Call: _e.mock.On("Seed", ctx)}
}

func (_c *MockDBer_Seed_Call) Run(run func(ctx context.Context)) *MockDBer_Seed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockDBer_Seed_Call) Return(err error) *MockDBer_Seed_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDBer_Seed_Call) RunAndReturn(run func(ctx context.Context) error) *MockDBer_Seed_Call {
	_c.Call.Return(run)
	return _c
}

// WithTx provides a mock function for the type MockDBer
func (_mock *MockDBer) WithTx(ctx context.Context, fn func(ctx context.Context, tx *sqlx.Tx) error) error {
	ret := _mock.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for WithTx")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(ctx context.Context, tx *sqlx.Tx) error) error); ok {
		r0 = returnFunc(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockDBer_WithTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTx'
type MockDBer_WithTx_Call struct {
	*mock.Call
}

// WithTx is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(ctx context.Context, tx *sqlx.Tx) error
func (_e *MockDBer_Expecter) WithTx(ctx interface{}, fn interface{}) *MockDBer_WithTx_Call {
	return &MockDBer_WithTx_Call{Call: _e.mock.On("WithTx", ctx, fn)}
}

func (_c *MockDBer_WithTx_Call) Run(run func(ctx context.Context, fn func(ctx context.Context, tx *sqlx.Tx) error)) *MockDBer_WithTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(ctx context.Context, tx *sqlx.Tx) error
		if args[1] != nil {
			arg1 = args[1].(func(ctx context.Context, tx *sqlx.Tx) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockDBer_WithTx_Call) Return(err error) *MockDBer_WithTx_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDBer_WithTx_Call) RunAndReturn(run func(ctx context.Context, fn func(ctx context.Context, tx *sqlx.Tx) error) error) *MockDBer_WithTx_Call {
	_c.Call.Return(run)
	return _c
}

// WithTxTimeout provides a mock function for the type MockDBer
func (_mock *MockDBer) WithTxTimeout(ctx context.Context, timeout time.Duration, fn func(ctx context.Context, tx *sqlx.Tx) error) error {
	ret := _mock.Called(ctx, timeout, fn)

	if len(ret) == 0 {
		panic("no return value specified for WithTxTimeout")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration, func(ctx context.Context, tx *sqlx.Tx) error) error); ok {
		r0 = returnFunc(ctx, timeout, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockDBer_WithTxTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTxTimeout'
type MockDBer_WithTxTimeout_Call struct {
	*mock.Call
}

// WithTxTimeout is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - fn func(ctx context.Context, tx *sqlx.Tx) error
func (_e *MockDBer_Expecter) WithTxTimeout(ctx interface{}, timeout interface{}, fn interface{}) *MockDBer_WithTxTimeout_Call {
	return &MockDBer_WithTxTimeout_Call{Call: _e.mock.On("WithTxTimeout", ctx, timeout, fn)}
}

func (_c *MockDBer_WithTxTimeout_Call) Run(run func(ctx context.Context, timeout time.Duration, fn func(ctx context.Context, tx *sqlx.Tx) error)) *MockDBer_WithTxTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		var arg2 func(ctx context.Context, tx *sqlx.Tx) error
		if args[2] != nil {
			arg2 = args[2].(func(ctx context.Context, tx *sqlx.Tx) error)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockDBer_WithTxTimeout_Call) Return(err error) *MockDBer_WithTxTimeout_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDBer_WithTxTimeout_Call) RunAndReturn(run func(ctx context.Context, timeout time.Duration, fn func(ctx context.Context, tx *sqlx.Tx) error) error) *MockDBer_WithTxTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// Writer provides a mock function for the type MockDBer
func (_mock *MockDBer) Writer() *sqlx.DB {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Writer")
	}

	var r0 *sqlx.DB
	if returnFunc, ok := ret.Get(0).(func() *sqlx.DB); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sqlx.DB)
		}
	}
	return r0
}

// MockDBer_Writer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Writer'
type MockDBer_Writer_Call struct {
	*mock.Call
}

// Writer is a helper method to define mock.On call
func (_e *MockDBer_Expecter) Writer() *MockDBer_Writer_Call {
	return &MockDBer_Writer_Call{Call: _e.mock.On("Writer")}
}

func (_c *MockDBer_Writer_Call) Run(run func()) *MockDBer_Writer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockDBer_Writer_Call) Return(dB *sqlx.DB) *MockDBer_Writer_Call {
	_c.Call.Return(dB)
	return _c
}

func (_c *MockDBer_Writer_Call) RunAndReturn(run func() *sqlx.DB) *MockDBer_Writer_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockFS creates a new instance of MockFS. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockFS(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockFS {
	mock := &MockFS{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockFS is an autogenerated mock type for the FS type
type MockFS struct {
	mock.Mock
}

type MockFS_Expecter struct {
	mock *mock.Mock
}

func (_m *MockFS) EXPECT() *MockFS_Expecter {
	return &MockFS_Expecter{mock: &_m.Mock}
}

// Open provides a mock function for the type MockFS
func (_mock *MockFS) Open(name string) (fs.File, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Open")
	}

	var r0 fs.File
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (fs.File, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) fs.File); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fs.File)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockFS_Open_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Open'
type MockFS_Open_Call struct {
	*mock.Call
}

// Open is a helper method to define mock.On call
//   - name string
func (_e *MockFS_Expecter) Open(name interface{}) *MockFS_Open_Call {
	return &MockFS_Open_Call{Call: _e.mock.On("Open", name)}
}

func (_c *MockFS_Open_Call) Run(run func(name string)) *MockFS_Open_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockFS_Open_Call) Return(file fs.File, err error) *MockFS_Open_Call {
	_c.Call.Return(file, err)
	return _c
}

func (_c *MockFS_Open_Call) RunAndReturn(run func(name string) (fs.File, error)) *MockFS_Open_Call {
	_c.Call.Return(run)
	return _c
}

// ReadDir provides a mock function for the type MockFS
func (_mock *MockFS) ReadDir(name string) ([]fs.DirEntry, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for ReadDir")
	}

	var r0 []fs.DirEntry
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) ([]fs.DirEntry, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) []fs.DirEntry); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]fs.DirEntry)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockFS_ReadDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadDir'
type MockFS_ReadDir_Call struct {
	*mock.Call
}

// ReadDir is a helper method to define mock.On call
//   - name string
func (_e *MockFS_Expecter) ReadDir(name interface{}) *MockFS_ReadDir_Call {
	return &MockFS_ReadDir_Call{Call: _e.mock.On("ReadDir", name)}
}

func (_c *MockFS_ReadDir_Call) Run(run func(name string)) *MockFS_ReadDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockFS_ReadDir_Call) Return(dirEntrys []fs.DirEntry, err error) *MockFS_ReadDir_Call {
	_c.Call.Return(dirEntrys, err)
	return _c
}

func (_c *MockFS_ReadDir_Call) RunAndReturn(run func(name string) ([]fs.DirEntry, error)) *MockFS_ReadDir_Call {
	_c.Call.Return(run)
	return _c
}

// ReadFile provides a mock function for the type MockFS
func (_mock *MockFS) ReadFile(name string) ([]byte, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for ReadFile")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) ([]byte, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) []byte); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockFS_ReadFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFile'
type MockFS_ReadFile_Call struct {
	*mock.Call
}

// ReadFile is a helper method to define mock.On call
//   - name string
func (_e *MockFS_Expecter) ReadFile(name interface{}) *MockFS_ReadFile_Call {
	return &MockFS_ReadFile_Call{Call: _e.mock.On("ReadFile", name)}
}

func (_c *MockFS_ReadFile_Call) Run(run func(name string)) *MockFS_ReadFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockFS_ReadFile_Call) Return(bytes []byte, err error) *MockFS_ReadFile_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *MockFS_ReadFile_Call) RunAndReturn(run func(name string) ([]byte, error)) *MockFS_ReadFile_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMailer creates a new instance of MockMailer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMailer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMailer {
	mock := &MockMailer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMailer is an autogenerated mock type for the Mailer type
type MockMailer struct {
	mock.Mock
}

type MockMailer_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMailer) EXPECT() *MockMailer_Expecter {
	return &MockMailer_Expecter{mock: &_m.Mock}
}

// BulkSend provides a mock function for the type MockMailer
func (_mock *MockMailer) BulkSend(templateName string, messages []core.EmailMessage, opts *core.RenderOptions) error {
	ret := _mock.Called(templateName, messages, opts)

	if len(ret) == 0 {
		panic("no return value specified for BulkSend")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, []core.EmailMessage, *core.RenderOptions) error); ok {
		r0 = returnFunc(templateName, messages, opts)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMailer_BulkSend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BulkSend'
type MockMailer_BulkSend_Call struct {
	*mock.Call
}

// BulkSend is a helper method to define mock.On call
//   - templateName string
//   - messages []core.EmailMessage
//   - opts *core.RenderOptions
func (_e *MockMailer_Expecter) BulkSend(templateName interface{}, messages interface{}, opts interface{}) *MockMailer_BulkSend_Call {
	return &MockMailer_BulkSend_Call{Call: _e.mock.On("BulkSend", templateName, messages, opts)}
}

func (_c *MockMailer_BulkSend_Call) Run(run func(templateName string, messages []core.EmailMessage, opts *core.RenderOptions)) *MockMailer_BulkSend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []core.EmailMessage
		if args[1] != nil {
			arg1 = args[1].([]core.EmailMessage)
		}
		var arg2 *core.RenderOptions
		if args[2] != nil {
			arg2 = args[2].(*core.RenderOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockMailer_BulkSend_Call) Return(err error) *MockMailer_BulkSend_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMailer_BulkSend_Call) RunAndReturn(run func(templateName string, messages []core.EmailMessage, opts *core.RenderOptions) error) *MockMailer_BulkSend_Call {
	_c.Call.Return(run)
	return _c
}

// Render provides a mock function for the type MockMailer
func (_mock *MockMailer) Render(templateName string, data map[string]any, opts *core.RenderOptions) (string, string, error) {
	ret := _mock.Called(templateName, data, opts)

	if len(ret) == 0 {
		panic("no return value specified for Render")
	}

	var r0 string
	var r1 string
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(string, map[string]any, *core.RenderOptions) (string, string, error)); ok {
		return returnFunc(templateName, data, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(string, map[string]any, *core.RenderOptions) string); ok {
		r0 = returnFunc(templateName, data, opts)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string, map[string]any, *core.RenderOptions) string); ok {
		r1 = returnFunc(templateName, data, opts)
	} else {
		r1 = ret.Get(1).(string)
	}
	if returnFunc, ok := ret.Get(2).(func(string, map[string]any, *core.RenderOptions) error); ok {
		r2 = returnFunc(templateName, data, opts)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockMailer_Render_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Render'
type MockMailer_Render_Call struct {
	*mock.Call
}

// Render is a helper method to define mock.On call
//   - templateName string
//   - data map[string]any
//   - opts *core.RenderOptions
func (_e *MockMailer_Expecter) Render(templateName interface{}, data interface{}, opts interface{}) *MockMailer_Render_Call {
	return &MockMailer_Render_Call{Call: _e.mock.On("Render", templateName, data, opts)}
}

func (_c *MockMailer_Render_Call) Run(run func(templateName string, data map[string]any, opts *core.RenderOptions)) *MockMailer_Render_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 map[string]any
		if args[1] != nil {
			arg1 = args[1].(map[string]any)
		}
		var arg2 *core.RenderOptions
		if args[2] != nil {
			arg2 = args[2].(*core.RenderOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockMailer_Render_Call) Return(html string, text string, err error) *MockMailer_Render_Call {
	_c.Call.Return(html, text, err)
	return _c
}

func (_c *MockMailer_Render_Call) RunAndReturn(run func(templateName string, data map[string]any, opts *core.RenderOptions) (string, string, error)) *MockMailer_Render_Call {
	_c.Call.Return(run)
	return _c
}

// Send provides a mock function for the type MockMailer
func (_mock *MockMailer) Send(templateName string, msg core.EmailMessage, opts *core.RenderOptions) error {
	ret := _mock.Called(templateName, msg, opts)

	if len(ret) == 0 {
		panic("no return value specified for Send")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, core.EmailMessage, *core.RenderOptions) error); ok {
		r0 = returnFunc(templateName, msg, opts)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMailer_Send_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Send'
type MockMailer_Send_Call struct {
	*mock.Call
}

// Send is a helper method to define mock.On call
//   - templateName string
//   - msg core.EmailMessage
//   - opts *core.RenderOptions
func (_e *MockMailer_Expecter) Send(templateName interface{}, msg interface{}, opts interface{}) *MockMailer_Send_Call {
	return &MockMailer_Send_Call{Call: _e.mock.On("Send", templateName, msg, opts)}
}

func (_c *MockMailer_Send_Call) Run(run func(templateName string, msg core.EmailMessage, opts *core.RenderOptions)) *MockMailer_Send_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 core.EmailMessage
		if args[1] != nil {
			arg1 = args[1].(core.EmailMessage)
		}
		var arg2 *core.RenderOptions
		if args[2] != nil {
			arg2 = args[2].(*core.RenderOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockMailer_Send_Call) Return(err error) *MockMailer_Send_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMailer_Send_Call) RunAndReturn(run func(templateName string, msg core.EmailMessage, opts *core.RenderOptions) error) *MockMailer_Send_Call {
	_c.Call.Return(run)
	return _c
}

// SetupPreviewRoutes provides a mock function for the type MockMailer
func (_mock *MockMailer) SetupPreviewRoutes(router chi.Router) {
	_mock.Called(router)
	return
}

// MockMailer_SetupPreviewRoutes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetupPreviewRoutes'
type MockMailer_SetupPreviewRoutes_Call struct {
	*mock.Call
}

// SetupPreviewRoutes is a helper method to define mock.On call
//   - router chi.Router
func (_e *MockMailer_Expecter) SetupPreviewRoutes(router interface{}) *MockMailer_SetupPreviewRoutes_Call {
	return &MockMailer_SetupPreviewRoutes_Call{Call: _e.mock.On("SetupPreviewRoutes", router)}
}

func (_c *MockMailer_SetupPreviewRoutes_Call) Run(run func(router chi.Router)) *MockMailer_SetupPreviewRoutes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 chi.Router
		if args[0] != nil {
			arg0 = args[0].(chi.Router)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMailer_SetupPreviewRoutes_Call) Return() *MockMailer_SetupPreviewRoutes_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockMailer_SetupPreviewRoutes_Call) RunAndReturn(run func(router chi.Router)) *MockMailer_SetupPreviewRoutes_Call {
	_c.Run(run)
	return _c
}

// TemplateOptions provides a mock function for the type MockMailer
func (_mock *MockMailer) TemplateOptions() *core.MailTemplateOptions {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TemplateOptions")
	}

	var r0 *core.MailTemplateOptions
	if returnFunc, ok := ret.Get(0).(func() *core.MailTemplateOptions); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.MailTemplateOptions)
		}
	}
	return r0
}

// MockMailer_TemplateOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TemplateOptions'
type MockMailer_TemplateOptions_Call struct {
	*mock.Call
}

// TemplateOptions is a helper method to define mock.On call
func (_e *MockMailer_Expecter) TemplateOptions() *MockMailer_TemplateOptions_Call {
	return &MockMailer_TemplateOptions_Call{Call: _e.mock.On("TemplateOptions")}
}

func (_c *MockMailer_TemplateOptions_Call) Run(run func()) *MockMailer_TemplateOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockMailer_TemplateOptions_Call) Return(mailTemplateOptions *core.MailTemplateOptions) *MockMailer_TemplateOptions_Call {
	_c.Call.Return(mailTemplateOptions)
	return _c
}

func (_c *MockMailer_TemplateOptions_Call) RunAndReturn(run func() *core.MailTemplateOptions) *MockMailer_TemplateOptions_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStorage creates a new instance of MockStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStorage {
	mock := &MockStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStorage is an autogenerated mock type for the Storage type
type MockStorage struct {
	mock.Mock
}

type MockStorage_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStorage) EXPECT() *MockStorage_Expecter {
	return &MockStorage_Expecter{mock: &_m.Mock}
}

// Delete provides a mock function for the type MockStorage
func (_mock *MockStorage) Delete(ctx context.Context, key string) error {
	ret := _mock.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockStorage_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockStorage_Expecter) Delete(ctx interface{}, key interface{}) *MockStorage_Delete_Call {
	return &MockStorage_Delete_Call{Call: _e.mock.On("Delete", ctx, key)}
}

func (_c *MockStorage_Delete_Call) Run(run func(ctx context.Context, key string)) *MockStorage_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_Delete_Call) Return(err error) *MockStorage_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_Delete_Call) RunAndReturn(run func(ctx context.Context, key string) error) *MockStorage_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Download provides a mock function for the type MockStorage
func (_mock *MockStorage) Download(ctx context.Context, key string) (io.ReadCloser, *core.ObjectMetadata, error) {
	ret := _mock.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Download")
	}

	var r0 io.ReadCloser
	var r1 *core.ObjectMetadata
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (io.ReadCloser, *core.ObjectMetadata, error)); ok {
		return returnFunc(ctx, key)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) io.ReadCloser); ok {
		r0 = returnFunc(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) *core.ObjectMetadata); ok {
		r1 = returnFunc(ctx, key)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*core.ObjectMetadata)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = returnFunc(ctx, key)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockStorage_Download_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Download'
type MockStorage_Download_Call struct {
	*mock.Call
}

// Download is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockStorage_Expecter) Download(ctx interface{}, key interface{}) *MockStorage_Download_Call {
	return &MockStorage_Download_Call{Call: _e.mock.On("Download", ctx, key)}
}

func (_c *MockStorage_Download_Call) Run(run func(ctx context.Context, key string)) *MockStorage_Download_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_Download_Call) Return(readCloser io.ReadCloser, objectMetadata *core.ObjectMetadata, err error) *MockStorage_Download_Call {
	_c.Call.Return(readCloser, objectMetadata, err)
	return _c
}

func (_c *MockStorage_Download_Call) RunAndReturn(run func(ctx context.Context, key string) (io.ReadCloser, *core.ObjectMetadata, error)) *MockStorage_Download_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateDownloadURL provides a mock function for the type MockStorage
func (_mock *MockStorage) GenerateDownloadURL(ctx context.Context, key string, expiresIn time.Duration) (*core.DownloadInfo, error) {
	ret := _mock.Called(ctx, key, expiresIn)

	if len(ret) == 0 {
		panic("no return value specified for GenerateDownloadURL")
	}

	var r0 *core.DownloadInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, time.Duration) (*core.DownloadInfo, error)); ok {
		return returnFunc(ctx, key, expiresIn)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, time.Duration) *core.DownloadInfo); ok {
		r0 = returnFunc(ctx, key, expiresIn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.DownloadInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, time.Duration) error); ok {
		r1 = returnFunc(ctx, key, expiresIn)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_GenerateDownloadURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateDownloadURL'
type MockStorage_GenerateDownloadURL_Call struct {
	*mock.Call
}

// GenerateDownloadURL is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiresIn time.Duration
func (_e *MockStorage_Expecter) GenerateDownloadURL(ctx interface{}, key interface{}, expiresIn interface{}) *MockStorage_GenerateDownloadURL_Call {
	return &MockStorage_GenerateDownloadURL_Call{Call: _e.mock.On("GenerateDownloadURL", ctx, key, expiresIn)}
}

func (_c *MockStorage_GenerateDownloadURL_Call) Run(run func(ctx context.Context, key string, expiresIn time.Duration)) *MockStorage_GenerateDownloadURL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 time.Duration
		if args[2] != nil {
			arg2 = args[2].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStorage_GenerateDownloadURL_Call) Return(downloadInfo *core.DownloadInfo, err error) *MockStorage_GenerateDownloadURL_Call {
	_c.Call.Return(downloadInfo, err)
	return _c
}

func (_c *MockStorage_GenerateDownloadURL_Call) RunAndReturn(run func(ctx context.Context, key string, expiresIn time.Duration) (*core.DownloadInfo, error)) *MockStorage_GenerateDownloadURL_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateUploadURL provides a mock function for the type MockStorage
func (_mock *MockStorage) GenerateUploadURL(ctx context.Context, key string, contentType string, expiresIn time.Duration) (*core.UploadInfo, error) {
	ret := _mock.Called(ctx, key, contentType, expiresIn)

	if len(ret) == 0 {
		panic("no return value specified for GenerateUploadURL")
	}

	var r0 *core.UploadInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) (*core.UploadInfo, error)); ok {
		return returnFunc(ctx, key, contentType, expiresIn)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) *core.UploadInfo); ok {
		r0 = returnFunc(ctx, key, contentType, expiresIn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.UploadInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, time.Duration) error); ok {
		r1 = returnFunc(ctx, key, contentType, expiresIn)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_GenerateUploadURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateUploadURL'
type MockStorage_GenerateUploadURL_Call struct {
	*mock.Call
}

// GenerateUploadURL is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - contentType string
//   - expiresIn time.Duration
func (_e *MockStorage_Expecter) GenerateUploadURL(ctx interface{}, key interface{}, contentType interface{}, expiresIn interface{}) *MockStorage_GenerateUploadURL_Call {
	return &MockStorage_GenerateUploadURL_Call{Call: _e.mock.On("GenerateUploadURL", ctx, key, contentType, expiresIn)}
}

func (_c *MockStorage_GenerateUploadURL_Call) Run(run func(ctx context.Context, key string, contentType string, expiresIn time.Duration)) *MockStorage_GenerateUploadURL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 time.Duration
		if args[3] != nil {
			arg3 = args[3].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStorage_GenerateUploadURL_Call) Return(uploadInfo *core.UploadInfo, err error) *MockStorage_GenerateUploadURL_Call {
	_c.Call.Return(uploadInfo, err)
	return _c
}

func (_c *MockStorage_GenerateUploadURL_Call) RunAndReturn(run func(ctx context.Context, key string, contentType string, expiresIn time.Duration) (*core.UploadInfo, error)) *MockStorage_GenerateUploadURL_Call {
	_c.Call.Return(run)
	return _c
}

// GetMetadata provides a mock function for the type MockStorage
func (_mock *MockStorage) GetMetadata(ctx context.Context, key string) (*core.ObjectMetadata, error) {
	ret := _mock.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetMetadata")
	}

	var r0 *core.ObjectMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*core.ObjectMetadata, error)); ok {
		return returnFunc(ctx, key)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *core.ObjectMetadata); ok {
		r0 = returnFunc(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ObjectMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_GetMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMetadata'
type MockStorage_GetMetadata_Call struct {
	*mock.Call
}

// GetMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockStorage_Expecter) GetMetadata(ctx interface{}, key interface{}) *MockStorage_GetMetadata_Call {
	return &MockStorage_GetMetadata_Call{Call: _e.mock.On("GetMetadata", ctx, key)}
}

func (_c *MockStorage_GetMetadata_Call) Run(run func(ctx context.Context, key string)) *MockStorage_GetMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_GetMetadata_Call) Return(objectMetadata *core.ObjectMetadata, err error) *MockStorage_GetMetadata_Call {
	_c.Call.Return(objectMetadata, err)
	return _c
}

func (_c *MockStorage_GetMetadata_Call) RunAndReturn(run func(ctx context.Context, key string) (*core.ObjectMetadata, error)) *MockStorage_GetMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockStorage
func (_mock *MockStorage) List(ctx context.Context, prefix string) ([]*core.ObjectMetadata, error) {
	ret := _mock.Called(ctx, prefix)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []*core.ObjectMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]*core.ObjectMetadata, error)); ok {
		return returnFunc(ctx, prefix)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []*core.ObjectMetadata); ok {
		r0 = returnFunc(ctx, prefix)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.ObjectMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, prefix)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockStorage_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - prefix string
func (_e *MockStorage_Expecter) List(ctx interface{}, prefix interface{}) *MockStorage_List_Call {
	return &MockStorage_List_Call{Call: _e.mock.On("List", ctx, prefix)}
}

func (_c *MockStorage_List_Call) Run(run func(ctx context.Context, prefix string)) *MockStorage_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_List_Call) Return(objectMetadatas []*core.ObjectMetadata, err error) *MockStorage_List_Call {
	_c.Call.Return(objectMetadatas, err)
	return _c
}

func (_c *MockStorage_List_Call) RunAndReturn(run func(ctx context.Context, prefix string) ([]*core.ObjectMetadata, error)) *MockStorage_List_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMetadata provides a mock function for the type MockStorage
func (_mock *MockStorage) UpdateMetadata(ctx context.Context, key string, metadata *core.ObjectMetadata) error {
	ret := _mock.Called(ctx, key, metadata)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMetadata")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *core.ObjectMetadata) error); ok {
		r0 = returnFunc(ctx, key, metadata)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_UpdateMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMetadata'
type MockStorage_UpdateMetadata_Call struct {
	*mock.Call
}

// UpdateMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - metadata *core.ObjectMetadata
func (_e *MockStorage_Expecter) UpdateMetadata(ctx interface{}, key interface{}, metadata interface{}) *MockStorage_UpdateMetadata_Call {
	return &MockStorage_UpdateMetadata_Call{Call: _e.mock.On("UpdateMetadata", ctx, key, metadata)}
}

func (_c *MockStorage_UpdateMetadata_Call) Run(run func(ctx context.Context, key string, metadata *core.ObjectMetadata)) *MockStorage_UpdateMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *core.ObjectMetadata
		if args[2] != nil {
			arg2 = args[2].(*core.ObjectMetadata)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStorage_UpdateMetadata_Call) Return(err error) *MockStorage_UpdateMetadata_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_UpdateMetadata_Call) RunAndReturn(run func(ctx context.Context, key string, metadata *core.ObjectMetadata) error) *MockStorage_UpdateMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// Upload provides a mock function for the type MockStorage
func (_mock *MockStorage) Upload(ctx context.Context, key string, reader io.Reader, metadata *core.ObjectMetadata) (*core.ObjectMetadata, error) {
	ret := _mock.Called(ctx, key, reader, metadata)

	if len(ret) == 0 {
		panic("no return value specified for Upload")
	}

	var r0 *core.ObjectMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, io.Reader, *core.ObjectMetadata) (*core.ObjectMetadata, error)); ok {
		return returnFunc(ctx, key, reader, metadata)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, io.Reader, *core.ObjectMetadata) *core.ObjectMetadata); ok {
		r0 = returnFunc(ctx, key, reader, metadata)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ObjectMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, io.Reader, *core.ObjectMetadata) error); ok {
		r1 = returnFunc(ctx, key, reader, metadata)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_Upload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upload'
type MockStorage_Upload_Call struct {
	*mock.Call
}

// Upload is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - reader io.Reader
//   - metadata *core.ObjectMetadata
func (_e *MockStorage_Expecter) Upload(ctx interface{}, key interface{}, reader interface{}, metadata interface{}) *MockStorage_Upload_Call {
	return &MockStorage_Upload_Call{Call: _e.mock.On("Upload", ctx, key, reader, metadata)}
}

func (_c *MockStorage_Upload_Call) Run(run func(ctx context.Context, key string, reader io.Reader, metadata *core.ObjectMetadata)) *MockStorage_Upload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 io.Reader
		if args[2] != nil {
			arg2 = args[2].(io.Reader)
		}
		var arg3 *core.ObjectMetadata
		if args[3] != nil {
			arg3 = args[3].(*core.ObjectMetadata)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStorage_Upload_Call) Return(objectMetadata *core.ObjectMetadata, err error) *MockStorage_Upload_Call {
	_c.Call.Return(objectMetadata, err)
	return _c
}

func (_c *MockStorage_Upload_Call) RunAndReturn(run func(ctx context.Context, key string, reader io.Reader, metadata *core.ObjectMetadata) (*core.ObjectMetadata, error)) *MockStorage_Upload_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWorker creates a new instance of MockWorker. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWorker(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWorker {
	mock := &MockWorker{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockWorker is an autogenerated mock type for the Worker type
type MockWorker struct {
	mock.Mock
}

type MockWorker_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWorker) EXPECT() *MockWorker_Expecter {
	return &MockWorker_Expecter{mock: &_m.Mock}
}

// GetClient provides a mock function for the type MockWorker
func (_mock *MockWorker) GetClient() *river.Client[pgx.Tx] {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetClient")
	}

	var r0 *river.Client[pgx.Tx]
	if returnFunc, ok := ret.Get(0).(func() *river.Client[pgx.Tx]); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*river.Client[pgx.Tx])
		}
	}
	return r0
}

// MockWorker_GetClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClient'
type MockWorker_GetClient_Call struct {
	*mock.Call
}

// GetClient is a helper method to define mock.On call
func (_e *MockWorker_Expecter) GetClient() *MockWorker_GetClient_Call {
	return &MockWorker_GetClient_Call{Call: _e.mock.On("GetClient")}
}

func (_c *MockWorker_GetClient_Call) Run(run func()) *MockWorker_GetClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWorker_GetClient_Call) Return(client *river.Client[pgx.Tx]) *MockWorker_GetClient_Call {
	_c.Call.Return(client)
	return _c
}

func (_c *MockWorker_GetClient_Call) RunAndReturn(run func() *river.Client[pgx.Tx]) *MockWorker_GetClient_Call {
	_c.Call.Return(run)
	return _c
}

// GetDBPool provides a mock function for the type MockWorker
func (_mock *MockWorker) GetDBPool() *pgxpool.Pool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetDBPool")
	}

	var r0 *pgxpool.Pool
	if returnFunc, ok := ret.Get(0).(func() *pgxpool.Pool); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pgxpool.Pool)
		}
	}
	return r0
}

// MockWorker_GetDBPool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDBPool'
type MockWorker_GetDBPool_Call struct {
	*mock.Call
}

// GetDBPool is a helper method to define mock.On call
func (_e *MockWorker_Expecter) GetDBPool() *MockWorker_GetDBPool_Call {
	return &MockWorker_GetDBPool_Call{Call: _e.mock.On("GetDBPool")}
}

func (_c *MockWorker_GetDBPool_Call) Run(run func()) *MockWorker_GetDBPool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWorker_GetDBPool_Call) Return(pool *pgxpool.Pool) *MockWorker_GetDBPool_Call {
	_c.Call.Return(pool)
	return _c
}

func (_c *MockWorker_GetDBPool_Call) RunAndReturn(run func() *pgxpool.Pool) *MockWorker_GetDBPool_Call {
	_c.Call.Return(run)
	return _c
}

// Insert provides a mock function for the type MockWorker
func (_mock *MockWorker) Insert(ctx context.Context, args river.JobArgs, opts *river.InsertOpts) (*rivertype.JobInsertResult, error) {
	ret := _mock.Called(ctx, args, opts)

	if len(ret) == 0 {
		panic("no return value specified for Insert")
	}

	var r0 *rivertype.JobInsertResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, river.JobArgs, *river.InsertOpts) (*rivertype.JobInsertResult, error)); ok {
		return returnFunc(ctx, args, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, river.JobArgs, *river.InsertOpts) *rivertype.JobInsertResult); ok {
		r0 = returnFunc(ctx, args, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rivertype.JobInsertResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, river.JobArgs, *river.InsertOpts) error); ok {
		r1 = returnFunc(ctx, args, opts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWorker_Insert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Insert'
type MockWorker_Insert_Call struct {
	*mock.Call
}

// Insert is a helper method to define mock.On call
//   - ctx context.Context
//   - args river.JobArgs
//   - opts *river.InsertOpts
func (_e *MockWorker_Expecter) Insert(ctx interface{}, args interface{}, opts interface{}) *MockWorker_Insert_Call {
	return &MockWorker_Insert_Call{Call: _e.mock.On("Insert", ctx, args, opts)}
}

func (_c *MockWorker_Insert_Call) Run(run func(ctx context.Context, args river.JobArgs, opts *river.InsertOpts)) *MockWorker_Insert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 river.JobArgs
		if args[1] != nil {
			arg1 = args[1].(river.JobArgs)
		}
		var arg2 *river.InsertOpts
		if args[2] != nil {
			arg2 = args[2].(*river.InsertOpts)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockWorker_Insert_Call) Return(jobInsertResult *rivertype.JobInsertResult, err error) *MockWorker_Insert_Call {
	_c.Call.Return(jobInsertResult, err)
	return _c
}

func (_c *MockWorker_Insert_Call) RunAndReturn(run func(ctx context.Context, args river.JobArgs, opts *river.InsertOpts) (*rivertype.JobInsertResult, error)) *MockWorker_Insert_Call {
	_c.Call.Return(run)
	return _c
}

// Queues provides a mock function for the type MockWorker
func (_mock *MockWorker) Queues() *river.QueueBundle {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Queues")
	}

	var r0 *river.QueueBundle
	if returnFunc, ok := ret.Get(0).(func() *river.QueueBundle); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*river.QueueBundle)
		}
	}
	return r0
}

// MockWorker_Queues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Queues'
type MockWorker_Queues_Call struct {
	*mock.Call
}

// Queues is a helper method to define mock.On call
func (_e *MockWorker_Expecter) Queues() *MockWorker_Queues_Call {
	return &MockWorker_Queues_Call{Call: _e.mock.On("Queues")}
}

func (_c *MockWorker_Queues_Call) Run(run func()) *MockWorker_Queues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWorker_Queues_Call) Return(queueBundle *river.QueueBundle) *MockWorker_Queues_Call {
	_c.Call.Return(queueBundle)
	return _c
}

func (_c *MockWorker_Queues_Call) RunAndReturn(run func() *river.QueueBundle) *MockWorker_Queues_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type MockWorker
func (_mock *MockWorker) Start(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWorker_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type MockWorker_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockWorker_Expecter) Start(ctx interface{}) *MockWorker_Start_Call {
	return &MockWorker_Start_Call{Call: _e.mock.On("Start", ctx)}
}

func (_c *MockWorker_Start_Call) Run(run func(ctx context.Context)) *MockWorker_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockWorker_Start_Call) Return(err error) *MockWorker_Start_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWorker_Start_Call) RunAndReturn(run func(ctx context.Context) error) *MockWorker_Start_Call {
	_c.Call.Return(run)
	return _c
}

// Stop provides a mock function for the type MockWorker
func (_mock *MockWorker) Stop(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWorker_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type MockWorker_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockWorker_Expecter) Stop(ctx interface{}) *MockWorker_Stop_Call {
	return &MockWorker_Stop_Call{Call: _e.mock.On("Stop", ctx)}
}

func (_c *MockWorker_Stop_Call) Run(run func(ctx context.Context)) *MockWorker_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockWorker_Stop_Call) Return(err error) *MockWorker_Stop_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWorker_Stop_Call) RunAndReturn(run func(ctx context.Context) error) *MockWorker_Stop_Call {
	_c.Call.Return(run)
	return _c
}

// StopAndCancel provides a mock function for the type MockWorker
func (_mock *MockWorker) StopAndCancel(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for StopAndCancel")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWorker_StopAndCancel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopAndCancel'
type MockWorker_StopAndCancel_Call struct {
	*mock.Call
}

// StopAndCancel is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockWorker_Expecter) StopAndCancel(ctx interface{}) *MockWorker_StopAndCancel_Call {
	return &MockWorker_StopAndCancel_Call{Call: _e.mock.On("StopAndCancel", ctx)}
}

func (_c *MockWorker_StopAndCancel_Call) Run(run func(ctx context.Context)) *MockWorker_StopAndCancel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockWorker_StopAndCancel_Call) Return(err error) *MockWorker_StopAndCancel_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWorker_StopAndCancel_Call) RunAndReturn(run func(ctx context.Context) error) *MockWorker_StopAndCancel_Call {
	_c.Call.Return(run)
	return _c
}

// Stopped provides a mock function for the type MockWorker
func (_mock *MockWorker) Stopped() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Stopped")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// MockWorker_Stopped_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stopped'
type MockWorker_Stopped_Call struct {
	*mock.Call
}

// Stopped is a helper method to define mock.On call
func (_e *MockWorker_Expecter) Stopped() *MockWorker_Stopped_Call {
	return &MockWorker_Stopped_Call{Call: _e.mock.On("Stopped")}
}

func (_c *MockWorker_Stopped_Call) Run(run func()) *MockWorker_Stopped_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWorker_Stopped_Call) Return(valCh <-chan struct{}) *MockWorker_Stopped_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *MockWorker_Stopped_Call) RunAndReturn(run func() <-chan struct{}) *MockWorker_Stopped_Call {
	_c.Call.Return(run)
	return _c
}
